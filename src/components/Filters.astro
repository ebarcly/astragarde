---
// FilterComponent.astro
 import { Slider } from "$lib/components/ui/slider/index";
---
<div class="p-4 rounded-sm bg-white shadow w-full max-w-full relative z-10 border border-zinc-200">
  <!-- Active Filter Tags -->
  <div id="activeFilterTags" class="mb-4 space-y-2 hidden" aria-live="polite" aria-atomic="true">
    <div id="availabilityTag" class="bg-green-700 text-white px-4 py-2 rounded flex items-center justify-between text-sm font-medium hidden transition-all duration-200 ease-in-out">
      <span></span>
      <button 
        class="ml-2 text-white hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-emerald-500 rounded"
        data-filter="availability"
        aria-label="Remove availability filter"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>
    <div id="priceTag" class="bg-blue-700 text-white px-4 py-2 rounded flex items-center justify-between text-sm font-medium hidden transition-all duration-200 ease-in-out">
      <span></span>
      <button 
        class="ml-2 text-white hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-emerald-500 rounded"
        data-filter="price"
        aria-label="Remove price filter"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>
  </div>

  <!-- Availability Filter -->
  <div class="mb-8">
    <button 
      class="flex items-center justify-between text-left mb-4 focus:outline-none w-full"
      id="availabilityToggle"
    >
      <h3 class="text-sm font-medium tracking-wider uppercase text-gray-900">
        Availability
      </h3>
      <svg class="w-4 h-4 text-gray-500 transform transition-transform" id="availabilityArrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
      </svg>
    </button>
    
    <div class="space-y-3" id="availabilityOptions">
      <button 
        class="flex items-center cursor-pointer text-left hover:bg-gray-100 p-1 rounded w-full"
        id="inStockButton"
        data-availability="true"
      >
        <div class="w-4 h-4 mr-3 flex-shrink-0 flex items-center justify-center border border-gray-300">
          <div class="w-3 h-3 bg-black hidden" id="inStockCheck"></div>
        </div>
        <span class="text-gray-900" id="inStockText">In stock</span>
      </button>
      
      <button 
        class="flex items-center cursor-pointer text-left hover:bg-gray-100 p-1 rounded w-full"
        id="outOfStockButton"
        data-availability="false"
      >
        <div class="w-4 h-4 mr-3 flex-shrink-0 flex items-center justify-center border border-gray-300">
          <div class="w-3 h-3 bg-black hidden" id="outOfStockCheck"></div>
        </div>
        <span class="text-gray-900" id="outOfStockText">Out of stock</span>
      </button>
    </div>
  </div>

  <!-- Price Filter -->
  <div class="mb-8 w-full">
    <button 
      class="flex items-center justify-between text-left mb-4 focus:outline-none w-full"
      id="priceToggle"
    >
      <h3 class="text-sm font-medium tracking-wider uppercase text-gray-900">
        Price
      </h3>
      <svg class="w-4 h-4 text-gray-500 transform transition-transform" id="priceArrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
      </svg>
    </button>
    
    <div class="space-y-4" id="priceOptions">
      <!-- Price Range Display -->
      <div class="flex justify-between text-sm text-gray-900">
        <span id="minPriceDisplay">$0.00</span>
        <span id="maxPriceDisplay">$199.00</span>
      </div>
      
      <!-- Price Range Slider -->
      <div class="relative w-full px-2 sm:px-4" id="priceSlider">
        <div class="h-2 bg-gray-200 rounded-full">
          <div class="h-2 bg-gray-800 rounded-full relative" id="priceRange">
            <!-- Left Handle -->
            <div 
              class="absolute -top-1 -left-2 w-4 h-4 bg-gray-800 rounded-full cursor-pointer border-2 border-white shadow focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-150"
              id="minHandle"
              role="slider"
              tabindex="0"
              aria-valuenow="0"
              aria-valuemin="0"
              aria-valuemax="198"
              aria-label="Minimum price"
              aria-valuetext="$0"
            ></div>
            <!-- Right Handle -->
            <div 
              class="absolute -top-1 -right-2 w-4 h-4 bg-gray-800 rounded-full cursor-pointer border-2 border-white shadow focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-150"
              id="maxHandle"
              role="slider"
              tabindex="0"
              aria-valuenow="199"
              aria-valuemin="1"
              aria-valuemax="199"
              aria-label="Maximum price"
              aria-valuetext="$199"
            ></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
import { filters } from "$/stores/filters";


interface FilterState {
  availability: string | null;
  minPrice: number | null;
  maxPrice: number | null;
}

class FilterComponent {
  private minPrice: number;
  private maxPrice: number;
  private currentMinPrice: number;
  private currentMaxPrice: number;
  private isDragging: boolean;
  private activeHandle: 'min' | 'max' | null;
  private filters: FilterState;

  constructor() {
    this.minPrice = 0;
    this.maxPrice = 199;
    this.currentMinPrice = 0;
    this.currentMaxPrice = 199;
    this.isDragging = false;
    this.activeHandle = null;
    this.filters = {
      availability: null,
      minPrice: null,
      maxPrice: null
    };
    
    this.init();
    this.loadFiltersFromURL();
  }
  
  private init(): void {
    this.bindEvents();
    this.updatePriceDisplay();
  }
  
  private bindEvents(): void {
    // Availability toggle
    const availabilityToggle = document.getElementById('availabilityToggle');
    if (availabilityToggle) {
      availabilityToggle.addEventListener('click', () => {
        this.toggleSection('availability');
      });
    }
    
    // Price toggle
    const priceToggle = document.getElementById('priceToggle');
    if (priceToggle) {
      priceToggle.addEventListener('click', () => {
        this.toggleSection('price');
      });
    }
    
    // Availability filters
    const inStockButton = document.getElementById('inStockButton');
    if (inStockButton) {
      inStockButton.addEventListener('click', () => {
        this.handleAvailabilityFilter('true');
      });
    }
    
    const outOfStockButton = document.getElementById('outOfStockButton');
    if (outOfStockButton) {
      outOfStockButton.addEventListener('click', () => {
        this.handleAvailabilityFilter('false');
      });
    }
    
    // Price slider events
    const minHandle = document.getElementById('minHandle');
    const maxHandle = document.getElementById('maxHandle');
    
    if (minHandle) {
      minHandle.addEventListener('mousedown', (e: MouseEvent) => this.startDrag(e, 'min'));
      minHandle.addEventListener('keydown', (e: KeyboardEvent) => this.handleSliderKey(e, 'min'));
    }
    if (maxHandle) {
      maxHandle.addEventListener('mousedown', (e: MouseEvent) => this.startDrag(e, 'max'));
      maxHandle.addEventListener('keydown', (e: KeyboardEvent) => this.handleSliderKey(e, 'max'));
    }
    
    document.addEventListener('mousemove', (e: MouseEvent) => this.drag(e));
    document.addEventListener('mouseup', () => this.endDrag());
    
    // Filter tag removal
    document.addEventListener('click', (e: MouseEvent) => {
      const filterButton = (e.target as HTMLElement).closest('[data-filter]');
      if (filterButton) {
        const filterType = filterButton.getAttribute('data-filter');
        if (filterType) {
          this.removeFilter(filterType);
        }
      }
    });
  }
  
  private toggleSection(section: 'availability' | 'price'): void {
    const options = document.getElementById(`${section}Options`);
    const arrow = document.getElementById(`${section}Arrow`);
    
    options?.classList.toggle('hidden');
    arrow?.classList.toggle('rotate-180');
  }
  
  private handleAvailabilityFilter(value: string): void {
    const inStockCheck = document.getElementById('inStockCheck');
    const outOfStockCheck = document.getElementById('outOfStockCheck');
    const inStockText = document.getElementById('inStockText');
    const outOfStockText = document.getElementById('outOfStockText');
    
    // Clear previous selections
    inStockCheck?.classList.add('hidden');
    outOfStockCheck?.classList.add('hidden');
    inStockText?.classList.remove('font-bold');
    outOfStockText?.classList.remove('font-bold');
    
    if (this.filters.availability === value) {
      // Deselect if clicking the same filter
      this.filters.availability = null;
    } else {
      // Select new filter
      this.filters.availability = value;
      
      if (value === 'true') {
        inStockCheck?.classList.remove('hidden');
        inStockText?.classList.add('font-bold');
      } else {
        outOfStockCheck?.classList.remove('hidden');
        outOfStockText?.classList.add('font-bold');
      }
    }
    
    this.updateFilterTags();
    this.updateURL();
    this.updateStore();
  }
  
  private startDrag(e: MouseEvent, handle: 'min' | 'max'): void {
    e.preventDefault();
    this.isDragging = true;
    this.activeHandle = handle;
    document.body.style.userSelect = 'none';
  }
  
  private drag(e: MouseEvent): void {
    if (!this.isDragging || !this.activeHandle) return;
    
    const slider = document.getElementById('priceSlider');
    if (!slider) return;

    const rect = slider.getBoundingClientRect();
    const percentage = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    const value = Math.round(this.minPrice + (this.maxPrice - this.minPrice) * percentage);
    
    if (this.activeHandle === 'min') {
      this.currentMinPrice = Math.min(value, this.currentMaxPrice - 1);
    } else {
      this.currentMaxPrice = Math.max(value, this.currentMinPrice + 1);
    }
    
    this.updateSliderPosition();
    this.updatePriceDisplay();
  }
  
  private endDrag(): void {
    if (this.isDragging) {
      this.isDragging = false;
      this.activeHandle = null;
      document.body.style.userSelect = '';
      
      // Apply filter only on mouse drop
      this.filters.minPrice = this.currentMinPrice > this.minPrice ? this.currentMinPrice : null;
      this.filters.maxPrice = this.currentMaxPrice < this.maxPrice ? this.currentMaxPrice : null;
      
      this.updateFilterTags();
      this.updateURL();
      this.updateStore();
    }
  }
  
  private updateSliderPosition(): void {
    const priceRange = document.getElementById('priceRange');
    const minHandle = document.getElementById('minHandle');
    const maxHandle = document.getElementById('maxHandle');
    if (!priceRange) return;

    const minPercent = (this.currentMinPrice - this.minPrice) / (this.maxPrice - this.minPrice) * 100;
    const maxPercent = (this.currentMaxPrice - this.minPrice) / (this.maxPrice - this.minPrice) * 100;
    priceRange.style.left = `${minPercent}%`;
    priceRange.style.width = `${maxPercent - minPercent}%`;

    // Update ARIA attributes for accessibility
    if (minHandle) {
      minHandle.setAttribute('aria-valuenow', String(this.currentMinPrice));
      minHandle.setAttribute('aria-valuemin', String(this.minPrice));
      minHandle.setAttribute('aria-valuemax', String(this.currentMaxPrice - 1));
      minHandle.setAttribute('aria-valuetext', `$${this.currentMinPrice.toFixed(2)}`);
    }
    if (maxHandle) {
      maxHandle.setAttribute('aria-valuenow', String(this.currentMaxPrice));
      maxHandle.setAttribute('aria-valuemin', String(this.currentMinPrice + 1));
      maxHandle.setAttribute('aria-valuemax', String(this.maxPrice));
      maxHandle.setAttribute('aria-valuetext', `$${this.currentMaxPrice.toFixed(2)}`);
    }
  }
  
  private updatePriceDisplay(): void {
    const minPriceDisplay = document.getElementById('minPriceDisplay');
    const maxPriceDisplay = document.getElementById('maxPriceDisplay');
    
    if (minPriceDisplay) {
      minPriceDisplay.textContent = `$${this.currentMinPrice.toFixed(2)}`;
    }
    if (maxPriceDisplay) {
      maxPriceDisplay.textContent = `$${this.currentMaxPrice.toFixed(2)}`;
    }
  }
  
  private updateFilterTags(): void {
    const activeFilterTags = document.getElementById('activeFilterTags');
    const availabilityTag = document.getElementById('availabilityTag');
    const priceTag = document.getElementById('priceTag');
    
    let hasActiveFilters = false;
    
    // Availability tag
    if (this.filters.availability !== null && availabilityTag) {
      const tagText = this.filters.availability === 'true' ? 'IN STOCK' : 'OUT OF STOCK';
      const span = availabilityTag.querySelector('span');
      if (span) {
        span.textContent = tagText;
      }
      availabilityTag.classList.remove('hidden');
      hasActiveFilters = true;
    } else if (availabilityTag) {
      availabilityTag.classList.add('hidden');
    }
    
    // Price tag
    if ((this.filters.minPrice !== null || this.filters.maxPrice !== null) && priceTag) {
      const minText = this.filters.minPrice ? `$${this.filters.minPrice}` : '$0';
      const maxText = this.filters.maxPrice ? `$${this.filters.maxPrice}` : '$199';
      const span = priceTag.querySelector('span');
      if (span) {
        span.textContent = `${minText} - ${maxText}`;
      }
      priceTag.classList.remove('hidden');
      hasActiveFilters = true;
    } else if (priceTag) {
      priceTag.classList.add('hidden');
    }
    
    // Show/hide container
    if (activeFilterTags) {
      if (hasActiveFilters) {
        activeFilterTags.classList.remove('hidden');
      } else {
        activeFilterTags.classList.add('hidden');
      }
    }
  }
  
  private removeFilter(filterType: string): void {
    if (filterType === 'availability') {
      this.filters.availability = null;
      const inStockCheck = document.getElementById('inStockCheck');
      const outOfStockCheck = document.getElementById('outOfStockCheck');
      const inStockText = document.getElementById('inStockText');
      const outOfStockText = document.getElementById('outOfStockText');
      
      inStockCheck?.classList.add('hidden');
      outOfStockCheck?.classList.add('hidden');
      inStockText?.classList.remove('font-bold');
      outOfStockText?.classList.remove('font-bold');
    } else if (filterType === 'price') {
      this.filters.minPrice = null;
      this.filters.maxPrice = null;
      this.currentMinPrice = this.minPrice;
      this.currentMaxPrice = this.maxPrice;
      this.updateSliderPosition();
      this.updatePriceDisplay();
    }
    
    this.updateFilterTags();
    this.updateURL();
    this.updateStore();
  }
  
  private updateURL(): void {
    const url = new URL(window.location.href);
    
    // Clear existing filter params
    url.searchParams.delete('availability');
    url.searchParams.delete('minPrice');
    url.searchParams.delete('maxPrice');
    
    // Add active filters
    if (this.filters.availability !== null) {
      url.searchParams.set('availability', this.filters.availability);
    }
    
    if (this.filters.minPrice !== null) {
      url.searchParams.set('minPrice', this.filters.minPrice.toString());
    }
    
    if (this.filters.maxPrice !== null) {
      url.searchParams.set('maxPrice', this.filters.maxPrice.toString());
    }
    
    // Update URL without page reload
    window.history.replaceState({}, '', url);
  }
  
  private updateStore(): void {
    // Create a clean filter object with only non-null values
    const activeFilters: Record<string, string | number> = {};
    
    if (this.filters.availability !== null) {
      activeFilters.availability = this.filters.availability;
    }
    
    if (this.filters.minPrice !== null) {
      activeFilters.minPrice = this.filters.minPrice;
    }
    
    if (this.filters.maxPrice !== null) {
      activeFilters.maxPrice = this.filters.maxPrice;
    }
    
    // Update the nanostores filters atom
    filters.set(activeFilters);
  }
  
  private loadFiltersFromURL(): void {
    const url = new URL(window.location.href);
    
    // Load availability filter
    const availability = url.searchParams.get('availability');
    if (availability === 'true' || availability === 'false') {
      this.handleAvailabilityFilter(availability);
    }
    
    // Load price filters
    const minPrice = url.searchParams.get('minPrice');
    const maxPrice = url.searchParams.get('maxPrice');
    
    if (minPrice && !isNaN(Number(minPrice))) {
      this.currentMinPrice = Number(minPrice);
      this.filters.minPrice = Number(minPrice);
    }
    
    if (maxPrice && !isNaN(Number(maxPrice))) {
      this.currentMaxPrice = Number(maxPrice);
      this.filters.maxPrice = Number(maxPrice);
    }
    
    this.updateSliderPosition();
    this.updatePriceDisplay();
    this.updateFilterTags();
    this.updateStore();
  }

  private handleSliderKey(e: KeyboardEvent, handle: 'min' | 'max'): void {
    let step = 1;
    if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
      if (handle === 'min') {
        this.currentMinPrice = Math.max(this.minPrice, this.currentMinPrice - step);
        if (this.currentMinPrice >= this.currentMaxPrice) this.currentMinPrice = this.currentMaxPrice - 1;
      } else {
        this.currentMaxPrice = Math.max(this.currentMinPrice + 1, this.currentMaxPrice - step);
      }
      this.updateSliderPosition();
      this.updatePriceDisplay();
      e.preventDefault();
    } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
      if (handle === 'min') {
        this.currentMinPrice = Math.min(this.currentMaxPrice - 1, this.currentMinPrice + step);
      } else {
        this.currentMaxPrice = Math.min(this.maxPrice, this.currentMaxPrice + step);
      }
      this.updateSliderPosition();
      this.updatePriceDisplay();
      e.preventDefault();
    } else if (e.key === 'Home') {
      if (handle === 'min') {
        this.currentMinPrice = this.minPrice;
      } else {
        this.currentMaxPrice = this.maxPrice;
      }
      this.updateSliderPosition();
      this.updatePriceDisplay();
      e.preventDefault();
    } else if (e.key === 'End') {
      if (handle === 'min') {
        this.currentMinPrice = this.currentMaxPrice - 1;
      } else {
        this.currentMaxPrice = this.maxPrice;
      }
      this.updateSliderPosition();
      this.updatePriceDisplay();
      e.preventDefault();
    } else if (e.key === 'Enter' || e.key === ' ') {
      // Apply filter on Enter/Space
      this.filters.minPrice = this.currentMinPrice > this.minPrice ? this.currentMinPrice : null;
      this.filters.maxPrice = this.currentMaxPrice < this.maxPrice ? this.currentMaxPrice : null;
      this.updateFilterTags();
      this.updateURL();
      this.updateStore();
      e.preventDefault();
    }
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  new FilterComponent();
});
</script>

<style>
  /* Responsive slider */
  #priceSlider {
    min-width: 180px;
    max-width: 100%;
    padding: 0 0.5rem;
  }
  @media (max-width: 640px) {
    #priceSlider {
      min-width: 120px;
      padding: 0 0.25rem;
    }
  }
  /* Focus style for slider handles */
  #minHandle:focus, #maxHandle:focus {
    outline: none;
    box-shadow: 0 0 0 3px #10b98166;
    border-color: #10b981;
    z-index: 2;
  }
  /* Tag animation */
  #activeFilterTags > div {
    transition: opacity 0.2s, transform 0.2s;
    opacity: 1;
    transform: translateY(0);
  }
  #activeFilterTags > div.hidden {
    opacity: 0;
    transform: translateY(-10px);
    pointer-events: none;
  }
  /* Slider handle hover/active */
  #minHandle:hover, #maxHandle:hover, #minHandle:active, #maxHandle:active {
    background: #bebebe;
    border-color: #eaeaea;
  }
  /* Make slider robust on all screens */
  #priceSlider, #priceRange {
    box-sizing: border-box;
  }
</style>
